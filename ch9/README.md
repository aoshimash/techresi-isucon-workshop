# 9.1 なぜ OS を学ぶのか？
OS はアプリケーションやデータベースにハードウェアリソースを提供する、いわば土台のような存在。
OS の動作をある程度学ぶことで、アプリケーションやデータベースがなぜ遅くなっているかについての解像度を高め、チューニングがより確実に進められることが期待できる。

本章では Linux をメインターゲットとして扱う。前半では Linux においてどのような高速化の取り組みが行われているかを紹介し、後半では具体的に遭遇することの多いトラブル及びそれに対するチューニングテクニックについて紹介する。

## 9.1.1 カーネルパラメータ
Linux は**カーネルパラメータ**という、OS のソースコードを書き換えデプロイすることなしに挙動を変える機能がある。これらの設定を変更することで大体の場合に対応することができる。

# 9.2 Linux Kernel の基礎知識
Linux では OS としてのコア機能を Linux Kernel というソフトウェアが担っている。OS 上で動作するアプリケーションは**システムコール**という命令を用いて Linux Kernel の機能を利用できる。

システムコールはアプリケーションへ OS のコア機能のインターフェースを提供しており、これによってアプリ側では様々なハードウェアごとの違いなど、OS 上で動作するアプリコーションがそれ以下のレイヤーにおける違いを意識することなく利用できるようになっている。

TODO: えーちゃんサーバー

日常的に利用しているコマンドも、実は多くのシステムコールを用いている。例えば、`ls` では 100 個以上ものシステムコールが用いられている。Linux では、`strace` というコマンドを用いてコマンドが用いているシステムコールを表示することができる。

```
$ strace ls
TODO
```

システムコールの一例として、`open(2)` がある。これは Linux においてアプリケーションから取り扱うためのファイルを開いたり作成したりするシステムコールである。`man` コマンドを用いて詳しいマニュアルを見ることができる:
```
man open 2
TODO
```
`open(2)` の 2 は、Linux man pages (Linux におけるマニュアル) の章番号を表している。`open` という文字列を用いている Linux 関連のシステムは多くあるため、その中でどれを指しているか明確にするために章番号をつけて表記することがある。以下が章番号と内容の対応の抜粋である。

| 章番号 | 概要 |
| :---: | :---: |
| 1 | Linux 上のユーザが実行できるコマンド |
| 2 | システムコール |
| 3 | C 言語で実装されたライブラリ |
| 8 | Linux 上の管理者権限を持ったユーザが実行できるコマンド |

`open` 関数は開きたいファイルパス (`pathname`)、開くためのフラグ (`flags`)、開く際の挙動を指定するモード (`mode_t`) を引数に持つ。`flags` はそのファイルを読み込みだけ (`O_RDONLY`) か、書き込みだけ (`O_WRONLY`) か、読み書き (`O_RDWR`) どちらも行うかの指定を行う。`mode_t` は、ファイルを書き込む際にファイルの最後から追記を行うモード (`O_APPEND`) や、ファイルが存在しなかった場合に開く前に作成するモード (`O_CREAT`) モードなどがある。  
どの引数においても読み書きするファイルのファイルシステムや、ハードウェアの情報を指定することはない。システムコールがうまくハードウェアや OS レイヤーのシステムを隠蔽できている一例。

これらの隠蔽されたシステムコールを境界として、Linux Kernel 側を**カーネル空間**、システムコールを利用する Linux OS 上のアプリケーションが動作する部分を**ユーザ空間**と呼ぶ。カーネル空間で処理が完結する場合は、ユーザ空間と比べてオーバーヘッドが少なく、より高速に動作する傾向にある。そのため、ミドルウェアなど速度が要求されるアプリケーションは直接カーネル空間で処理を行うよう実装する場合もある。

