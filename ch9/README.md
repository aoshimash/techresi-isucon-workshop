# 9.1 なぜ OS を学ぶのか？
OS はアプリケーションやデータベースにハードウェアリソースを提供する、いわば土台のような存在。
OS の動作をある程度学ぶことで、アプリケーションやデータベースがなぜ遅くなっているかについての解像度を高め、チューニングがより確実に進められることが期待できる。

本章では Linux をメインターゲットとして扱う。前半では Linux においてどのような高速化の取り組みが行われているかを紹介し、後半では具体的に遭遇することの多いトラブル及びそれに対するチューニングテクニックについて紹介する。

## 9.1.1 カーネルパラメータ
Linux は**カーネルパラメータ**という、OS のソースコードを書き換えデプロイすることなしに挙動を変える機能がある。これらの設定を変更することで大体の場合に対応することができる。

# 9.2 Linux Kernel の基礎知識
Linux では OS としてのコア機能を Linux Kernel というソフトウェアが担っている。OS 上で動作するアプリケーションは**システムコール**という命令を用いて Linux Kernel の機能を利用できる。

システムコールはアプリケーションへ OS のコア機能のインターフェースを提供しており、これによってアプリ側では様々なハードウェアごとの違いなど、OS 上で動作するアプリコーションがそれ以下のレイヤーにおける違いを意識することなく利用できるようになっている。

日常的に利用しているコマンドも、実は多くのシステムコールを用いている。例えば、`ls` では 100 個以上ものシステムコールが用いられている。Linux では、`strace` というコマンドを用いてコマンドが用いているシステムコールを表示することができる。

```
$ strace ls
TODO
```

システムコールの一例として、`open(2)` がある。これは Linux においてアプリケーションから取り扱うためのファイルを開いたり作成したりするシステムコールである。`man` コマンドを用いて詳しいマニュアルを見ることができる:
```
man open 2
TODO
```
`open(2)` の 2 は、Linux man pages (Linux におけるマニュアル) の章番号を表している。`open` という文字列を用いている Linux 関連のシステムは多くあるため、その中でどれを指しているか明確にするために章番号をつけて表記することがある。以下が章番号と内容の対応の抜粋である。

| 章番号 | 概要 |
| :---: | :---: |
| 1 | Linux 上のユーザが実行できるコマンド |
| 2 | システムコール |
| 3 | C 言語で実装されたライブラリ |
| 8 | Linux 上の管理者権限を持ったユーザが実行できるコマンド |

`open` 関数は開きたいファイルパス (`pathname`)、開くためのフラグ (`flags`)、開く際の挙動を指定するモード (`mode_t`) を引数に持つ。`flags` はそのファイルを読み込みだけ (`O_RDONLY`) か、書き込みだけ (`O_WRONLY`) か、読み書き (`O_RDWR`) どちらも行うかの指定を行う。`mode_t` は、ファイルを書き込む際にファイルの最後から追記を行うモード (`O_APPEND`) や、ファイルが存在しなかった場合に開く前に作成するモード (`O_CREAT`) モードなどがある。  
どの引数においても読み書きするファイルのファイルシステムや、ハードウェアの情報を指定することはない。システムコールがうまくハードウェアや OS レイヤーのシステムを隠蔽できている一例。

これらの隠蔽されたシステムコールを境界として、Linux Kernel 側を**カーネル空間**、システムコールを利用する Linux OS 上のアプリケーションが動作する部分を**ユーザ空間**と呼ぶ。カーネル空間で処理が完結する場合は、ユーザ空間と比べてオーバーヘッドが少なく、より高速に動作する傾向にある。そのため、ミドルウェアなど速度が要求されるアプリケーションは直接カーネル空間で処理を行うよう実装する場合もある。

# 9.3 Linux のプロセス管理
ユーザー間で動作するアプリケーションは全て**プロセス**として扱われる。`ps` コマンドを用いることで動作しているプロセスの一覧を確認できる。
```
$ ps
```

**PID** (Process ID) は各プロセスごとに割り振られるユニークな ID で、プロセスが起動するごとに PID がインクリメントされて値が割り振られる。PID が 1 である Linux において最初に起動されるプロセスは **init** と呼ばれている。Linux においてはプロセスは親子関係があり、プロセスを起動するためには親プロセスを元にして子プロセスを作成する。そのすべてのプロセスの親となるのが **init** である。近年では init の実装として `systemd` が多く用いられている。

親プロセスが小プロセスを生成することを、用いるシステムコール `fork` からちなんで 「fork する」という。`fork(2)` は自らのプロセスをコピーし、その後 `execve(2)` というシステムコールを用いてバイナリを実行することで子プロセスを作成することができる。

Linux では、CPU やメモリなどのリソースはプロセスごとに割り振られているため、子プロセスを作成することで、そのプロセス専用に独立したリソース空間の構築と確保ができる。ここで割り当てられる CPU やメモリは、「仮想 CPU」「仮装メモリ」と呼ばれる Linux Kernel 上で仮装化されたリソースである。Linux Kernel 上でリソースを仮装化することで、ユーザ空間のプロセスは実メモリを意識することなく効率的にリソースを利用できる。

このようにプロセス間のリソースは分離されているが、プロセス間には 1 つ以上の**スレッド**を持つことができる。処理はスレッド単位で行うことができるので、複数スレッドを用いることで並列処理が実現できる。また、プロセスと違い、同プロセス内にあるスレッドは同じリソースを使うことができる。

# 9.4 Linux のネットワーク
## 9.4.1 ネットワークのメトリクス
ネットワークにおいて重要なメトリクスとして、スループットとレイテンシがある。スループットは同時に処理できる量、レイテンシはネットワーク通信を処理するためにかかった時間を指す。

ネットワーク通信は通信先のマシン、2点間をつなぐネットワーク経路、信号を処理する NIC (Network Interface Card)、Linux Kernel を介して自分のアプリケーションまで届くため、ネットワークのメトリクスはこれらのいずれかの性能が変わると変わりうることに注意。改善したい場合は利用しているネットワークの変更を検討し、自社でネットワークを設計している場合はアーキテクチャや利用しているハードウェアを再検討する。

![]()

# 9.4.2 Linux Kernel におけるパケット処理の効率化
Web アプリケーションにおいて、受信側ホストはどのタイミングでパケットが受信されるかを事前に予測することはできないため、Linux Kernel はパケットを NIC から受け取った段階で CPU に対して「即座にパケットを処理せよ」という割り込み命令を出す。これは **Inturrupt** と呼ばれている。
